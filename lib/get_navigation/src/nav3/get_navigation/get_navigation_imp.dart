import 'dart:async';

import 'package:flutter/material.dart';

import '../../../../get_state_manager/src/simple/get_state.dart';
import '../../../../get_state_manager/src/simple/list_notifier.dart';
import '../../../../get_utils/src/platform/platform.dart';
import '../../../../route_manager.dart';
import '../../root/parse_route.dart';
import '../url_strategy/url_strategy.dart';

class GetNavigation extends RouterDelegate<RouteDecoder>
    with
        ListNotifierSingleMixin,
        PopNavigatorRouterDelegateMixin<RouteDecoder>,
        IGetNavigation {
  final _activePages = <RouteDecoder>[];
  final GetPage _unknownPage;
  final List<NavigatorObserver>? navigatorObservers;
  final String? restorationScopeId;
  @override
  final navigatorKey = GlobalKey<NavigatorState>();

  static late final GetNavigation instance;

  @override
  Future<void> setInitialRoutePath(RouteDecoder configuration) async {
    setNewRoutePath(configuration);
  }

  GetNavigation({
    String? initialPage,
    required List<GetPage> pages,
    GetPage? unknownPage,
    this.navigatorObservers,
    this.restorationScopeId,
    bool showHashOnUrl = false,
  }) : _unknownPage = unknownPage ??
            GetPage(
              name: '/404',
              page: () =>
                  Scaffold(body: Center(child: Text('Route not found'))),
            ) {
    if (!showHashOnUrl && GetPlatform.isWeb) setUrlStrategy();
    Get.addPages(pages);
    Get.addPage(_unknownPage);
    // setNewRoutePath(_buildPageSettings(_initialPage));
  }

  PageSettings _buildPageSettings(String page, [Object? data]) {
    var uri = Uri.parse(page);
    return PageSettings(uri, data);
  }

  @protected
  RouteDecoder? _getRouteDecoder<T>(PageSettings arguments) {
    var page = arguments.uri.path;
    final parameters = arguments.params;
    if (parameters.isNotEmpty) {
      final uri = Uri(path: page, queryParameters: parameters);
      page = uri.toString();
    }

    final decoder = Get.routeTree.matchRoute(page, arguments: arguments);
    final route = decoder.route;
    if (route == null) return null;
    return _configureRouterDecoder(decoder, arguments);
    // decoder.replaceArguments(arguments);
    //decoder.replaceParameters(arguments)

    // return decoder;
  }

  @protected
  RouteDecoder _configureRouterDecoder<T>(
      RouteDecoder decoder, PageSettings arguments) {
    // final decoder = Get.routeTree.matchRoute(page.name, arguments: arguments);

    decoder.route = decoder.route?.copy(
      completer: _activePages.isEmpty ? null : Completer(),
      arguments: arguments,
      parameters: arguments.params,
    );
    return decoder;
  }

  Future<T?> _push<T>(RouteDecoder activePage) async {
    // final activePage = _configureRouterDecoder<T>(page, arguments);
    final onStackPage = _activePages.firstWhereOrNull(
        (element) => element.route?.key == activePage.route?.key);

    /// There are no duplicate routes in the stack
    if (onStackPage == null) {
      _activePages.add(activePage);
    } else {
      /// There are duplicate routes, reorder
      _activePages.remove(onStackPage);
      _activePages.add(onStackPage);
    }
    refresh();
    return activePage.route?.completer?.future as Future<T?>?;
  }

  Future<T?> _replace<T>(PageSettings arguments, GetPage<T> page) async {
    final index = _activePages.length > 1 ? _activePages.length - 1 : 0;
    Get.addPage(page);

    final route = _getRouteDecoder(arguments);

    final activePage = _configureRouterDecoder<T>(route!, arguments);

    _activePages[index] = activePage;

    refresh();
    final result = await activePage.route?.completer?.future as Future<T?>;
    Get.removePage(page);

    return result;
  }

  Future<T?> _replaceNamed<T>(RouteDecoder activePage) async {
    final index = _activePages.length > 1 ? _activePages.length - 1 : 0;
    // final activePage = _configureRouterDecoder<T>(page, arguments);
    _activePages[index] = activePage;

    refresh();
    final result = await activePage.route?.completer?.future as Future<T?>;
    return result;
  }

  /// Takes a route [name] String generated by [to], [off], [offAll]
  /// (and similar context navigation methods), cleans the extra chars and
  /// accommodates the format.
  /// TODO: check for a more "appealing" URL naming convention.
  /// `() => MyHomeScreenView` becomes `/my-home-screen-view`.
  String _cleanRouteName(String name) {
    name = name.replaceAll('() => ', '');

    /// uncommonent for URL styling.
    // name = name.paramCase!;
    if (!name.startsWith('/')) {
      name = '/$name';
    }
    return Uri.tryParse(name)?.toString() ?? name;
  }

  @protected
  void _popWithResult<T>([T? result]) {
    final completer = _activePages.removeLast().route?.completer;
    if (completer?.isCompleted == false) completer!.complete(result);
  }

  @override
  Future<T?> toNamed<T>(String page, [Object? data]) async {
    final arguments = _buildPageSettings(page, data);
    final route = _getRouteDecoder<T>(arguments);
    if (route != null) {
      return _push<T>(route);
    }
    throw 'Route $page not registered';
  }

  @override
  Future<T?> to<T>(
    Widget Function() page, {
    bool? opaque,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    int? id,
    String? routeName,
    bool fullscreenDialog = false,
    dynamic arguments,
    Binding? binding,
    bool preventDuplicates = true,
    bool? popGesture,
    bool showCupertinoParallax = true,
    double Function(BuildContext context)? gestureWidth,
  }) async {
    routeName = _cleanRouteName("/${page.runtimeType}");
    final getPage = GetPage<T>(
      name: routeName,
      opaque: opaque ?? true,
      page: page,
      gestureWidth: gestureWidth,
      showCupertinoParallax: showCupertinoParallax,
      popGesture: popGesture ?? Get.defaultPopGesture,
      transition: transition ?? Get.defaultTransition,
      curve: curve ?? Get.defaultTransitionCurve,
      fullscreenDialog: fullscreenDialog,
      binding: binding,
      transitionDuration: duration ?? Get.defaultTransitionDuration,
    );
    Get.addPage(getPage);
    final args = _buildPageSettings(routeName, arguments);
    final route = _getRouteDecoder<T>(args);
    final result = await _push<T>(route!);
    Get.removePage(getPage);
    return result;
  }

  @override
  Future<T?> off<T>(
    Widget Function() page, {
    bool? opaque,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    int? id,
    String? routeName,
    bool fullscreenDialog = false,
    dynamic arguments,
    Binding? binding,
    bool preventDuplicates = true,
    bool? popGesture,
    bool showCupertinoParallax = true,
    double Function(BuildContext context)? gestureWidth,
  }) async {
    routeName = _cleanRouteName("/${page.runtimeType}");
    final route = GetPage<T>(
      name: routeName,
      opaque: opaque ?? true,
      page: page,
      gestureWidth: gestureWidth,
      showCupertinoParallax: showCupertinoParallax,
      popGesture: popGesture ?? Get.defaultPopGesture,
      transition: transition ?? Get.defaultTransition,
      curve: curve ?? Get.defaultTransitionCurve,
      fullscreenDialog: fullscreenDialog,
      binding: binding,
      transitionDuration: duration ?? Get.defaultTransitionDuration,
    );

    final args = _buildPageSettings(routeName, arguments);
    return _replace(args, route);
  }

  @override
  Future<T?>? offAll<T>(
    Widget Function() page, {
    bool Function(GetPage route)? predicate,
    bool opaque = true,
    bool? popGesture,
    int? id,
    String? routeName,
    dynamic arguments,
    Binding? binding,
    bool fullscreenDialog = false,
    Transition? transition,
    Curve? curve,
    Duration? duration,
    bool showCupertinoParallax = true,
    double Function(BuildContext context)? gestureWidth,
  }) async {
    routeName = _cleanRouteName("/${page.runtimeType}");
    final route = GetPage<T>(
      name: routeName,
      opaque: opaque,
      page: page,
      gestureWidth: gestureWidth,
      showCupertinoParallax: showCupertinoParallax,
      popGesture: popGesture ?? Get.defaultPopGesture,
      transition: transition ?? Get.defaultTransition,
      curve: curve ?? Get.defaultTransitionCurve,
      fullscreenDialog: fullscreenDialog,
      binding: binding,
      transitionDuration: duration ?? Get.defaultTransitionDuration,
    );

    final args = _buildPageSettings(routeName, arguments);

    final newPredicate = predicate ?? (route) => false;

    while (_activePages.length > 1 && !newPredicate(_activePages.last.route!)) {
      _popWithResult();
    }

    return _replace(args, route);
  }

  @override
  Future<T?>? offAllNamed<T>(
    String page, {
    bool Function(GetPage route)? predicate,
    dynamic arguments,
    int? id,
    Map<String, String>? parameters,
  }) async {
    final args = _buildPageSettings(page, arguments);
    final route = _getRouteDecoder<T>(args);
    if (route == null) return null;

    //  final newPredicate = predicate ?? (route) => false;

    while (_activePages.length > 1) {
      _activePages.removeLast();
    }

    return _replaceNamed(route);
  }

  @override
  Future<T?> offNamed<T>(String page, [Object? data]) async {
    final arguments = _buildPageSettings(page, data);
    final route = _getRouteDecoder<T>(arguments);
    if (route == null) return null;
    _popWithResult();
    return _push<T>(route);
  }

  @override
  Future<T?> toAndOffUntil<T>(
    String page,
    bool Function(GetPage) predicate, [
    Object? data,
  ]) async {
    final arguments = _buildPageSettings(page, data);

    final route = _getRouteDecoder<T>(arguments);

    if (route == null) return null;

    while (_activePages.isNotEmpty && !predicate(_activePages.last.route!)) {
      _popWithResult();
    }

    return _push<T>(route);
  }

  @override
  void back<T>([T? result]) {
    _checkIfCanBack();
    _popWithResult<T>(result);
    refresh();
  }

  void _checkIfCanBack() {
    assert(() {
      if (!canBack) {
        final last = _activePages.last;
        final name = last.route?.name;
        throw 'The page $name cannot be popped';
      }
      return true;
    }());
  }

  @override
  Future<R?> backAndtoNamed<T, R>(String page,
      {T? result, Object? data}) async {
    final arguments = _buildPageSettings(page, data);
    final route = _getRouteDecoder<R>(arguments);
    if (route == null) return null;
    _popWithResult<T>(result);
    return _push<R>(route);
  }

  @override
  void backUntil(bool Function(GetPage) predicate) {
    while (canBack && !predicate(_activePages.last.route!)) {
      _popWithResult();
    }

    refresh();
  }

  @override
  void goToUnknownPage([bool clearPages = false]) {
    if (clearPages) _activePages.clear();

    final pageSettings = _buildPageSettings(_unknownPage.name);
    final routeDecoder = _getRouteDecoder(pageSettings);

    _push(routeDecoder!);
  }

  @override
  bool get canBack => _activePages.length > 1;

  bool _onPopPage(Route route, result) {
    if (!route.didPop(result)) return false;
    _popWithResult(result);
    refresh();
    return true;
  }

  @override
  Widget build(BuildContext context) {
    if (_activePages.isEmpty) return SizedBox.shrink();
    return GetNavigator(
      key: navigatorKey,
      restorationScopeId: restorationScopeId,
      observers: navigatorObservers,
      pages: _activePages.map((decoder) => decoder.route!).toList(),
      onPopPage: _onPopPage,
    );
  }

  @override
  Future<void> setNewRoutePath(RouteDecoder configuration) async {
    // if (_activePages.isEmpty) return;
    final page = configuration.route;
    if (page == null) {
      goToUnknownPage();
      return;
    } else {
      _push(configuration);
    }
  }

  @override
  RouteDecoder? get currentConfiguration {
    if (_activePages.isEmpty) {
      return null;
    }
    return _activePages.last;
  }
}
